#!/bin/sh
# shellcheck shell=ash
# shellcheck disable=SC3043

set -eu

if (set -o pipefail) 2> /dev/null; then
    # shellcheck disable=SC3040
    set -o pipefail
fi

# OpenWRT Captive Portal Monitor and Auto-Redirect Script
# Проверяет интернет, перехватывает HTTP-трафик клиентов LAN на captive portal

# ============================================================================
# КОНФИГУРАЦИЯ
# ============================================================================

# Сетевые интерфейсы
WIFI_INTERFACE="${WIFI_INTERFACE:-phy1-sta0}"
WIFI_LOGICAL="${WIFI_LOGICAL:-wwan}"
LAN_INTERFACE="${LAN_INTERFACE:-}"
LAN_IP="${LAN_IP:-}"
LAN_IPV6="${LAN_IPV6:-}"

# Серверы для проверки интернета
PING_SERVERS="1.1.1.1 8.8.8.8 9.9.9.9"
PING_COUNT=1
PING_TIMEOUT=2

# Параметры проверки
GATEWAY_CHECK_RETRIES=3
GATEWAY_CHECK_DELAY=3
INTERNET_CHECK_RETRIES=3
INTERNET_CHECK_DELAY=5
MAX_WAIT_TIME=90

# Интервал мониторинга (секунды)
MONITOR_INTERVAL=60

# Проверка captive-портала
CAPTIVE_CHECK_URLS="http://connectivitycheck.gstatic.com/generate_204 http://detectportal.firefox.com/success.txt"
CAPTIVE_CURL_TIMEOUT=7
CAPTIVE_RECHECK_DELAY=5
CAPTIVE_RECOVERY_TIMEOUT=60

# DNS и HTTP перехват
DNSMASQ_CAPTIVE_DIR="/tmp/dnsmasq.d"
DNSMASQ_CAPTIVE_CONF="/tmp/dnsmasq.d/captive_intercept.conf"
HTTPD_PORT=8080
HTTPD_ROOT="/tmp/captive_httpd"
HTTPD_PIDFILE="/tmp/captive_httpd.pid"
HTTPD_INDEX="/tmp/captive_httpd/index.html"
HTTPD_IPV6_READY=0
CAPTIVE_NAT_CHAIN="CAPTIVE_HTTP_REDIRECT"
CAPTIVE_DNS_CHAIN="CAPTIVE_DNS_REDIRECT"
NFT_TABLE_NAME="captive_monitor"
NFT_CHAIN_NAME="prerouting"
REQUESTED_FIREWALL_BACKEND="${REQUESTED_FIREWALL_BACKEND:-}"
FIREWALL_BACKEND=""
FIREWALL_BACKEND_DETECTED=0

# Последний обнаруженный портал
CAPTIVE_PORTAL_URL=""
CAPTIVE_PORTAL_HOST=""

# Состояние перехвата
CAPTIVE_ACTIVE=0
ACTIVE_PORTAL_URL=""
ACTIVE_PORTAL_HOST=""
ACTIVE_PORTAL_IP=""
ACTIVE_PORTAL_IP6=""

# Логирование
LOG_TAG="captive-monitor"
ENABLE_SYSLOG=1

# ============================================================================
# UCI КОНФИГУРАЦИЯ
# ============================================================================

DEFAULT_MODE="oneshot"

uci_safe_get() {
    if command -v uci > /dev/null 2>&1; then
        uci -q get "$1" 2> /dev/null || true
    else
        printf ''
    fi
}

load_uci_config() {
    if ! command -v uci > /dev/null 2>&1; then
        return 0
    fi

    local section="captive-monitor.config"
    local value

    value=$(uci_safe_get "${section}.wifi_interface")
    [ -n "$value" ] && WIFI_INTERFACE="$value"

    value=$(uci_safe_get "${section}.wifi_logical")
    [ -n "$value" ] && WIFI_LOGICAL="$value"

    value=$(uci_safe_get "${section}.lan_interface")
    [ -n "$value" ] && LAN_INTERFACE="$value"

    value=$(uci_safe_get "${section}.lan_ip")
    [ -n "$value" ] && LAN_IP="$value"

    value=$(uci_safe_get "${section}.lan_ipv6")
    [ -n "$value" ] && LAN_IPV6="$value"

    value=$(uci_safe_get "${section}.firewall_backend")
    [ -n "$value" ] && REQUESTED_FIREWALL_BACKEND="$value"

    value=$(uci_safe_get "${section}.monitor_interval")
    [ -n "$value" ] && MONITOR_INTERVAL="$value"

    value=$(uci_safe_get "${section}.ping_servers")
    [ -n "$value" ] && PING_SERVERS="$value"

    value=$(uci_safe_get "${section}.captive_check_urls")
    [ -n "$value" ] && CAPTIVE_CHECK_URLS="$value"

    value=$(uci_safe_get "${section}.enable_syslog")
    case "$value" in
        0 | false | no | disabled)
            ENABLE_SYSLOG=0
            ;;
        1 | true | yes | enabled)
            ENABLE_SYSLOG=1
            ;;
    esac

    value=$(uci_safe_get "${section}.mode")
    case "$value" in
        monitor | oneshot)
            DEFAULT_MODE="$value"
            ;;
    esac
}

# ============================================================================
# ФУНКЦИИ ЛОГИРОВАНИЯ
# ============================================================================

log_info() {
    local msg="$1"
    echo "[INFO] $msg"
    [ "$ENABLE_SYSLOG" = "1" ] && logger -t "$LOG_TAG" -p user.info "$msg"
}

log_warn() {
    local msg="$1"
    echo "[WARN] $msg" >&2
    [ "$ENABLE_SYSLOG" = "1" ] && logger -t "$LOG_TAG" -p user.warn "$msg"
}

log_error() {
    local msg="$1"
    echo "[ERROR] $msg" >&2
    [ "$ENABLE_SYSLOG" = "1" ] && logger -t "$LOG_TAG" -p user.err "$msg"
}

# ============================================================================
# УТИЛИТЫ
# ============================================================================

trim() {
    local value="$1"
    value="${value%\r}"
    echo "$value"
}

normalize_url() {
    local raw="$1"
    local base="$2"
    local scheme host base_dir

    case "$raw" in
        http://* | https://*)
            echo "$raw"
            return 0
            ;;
        //*)
            echo "http:${raw}"
            return 0
            ;;
        /*)
            scheme="${base%%://*}"
            [ -z "$scheme" ] && scheme="http"
            host=$(echo "$base" | cut -d/ -f3)
            echo "${scheme}://${host}${raw}"
            return 0
            ;;
    esac

    base_dir=$(echo "$base" | sed 's#[^/]*$##')
    if [ -n "$base_dir" ]; then
        echo "${base_dir}${raw}"
    else
        echo "$raw"
    fi
}

extract_host_from_url() {
    local url="$1"
    url="${url#http://}"
    url="${url#https://}"
    url="${url#//}"
    url="${url%%/*}"
    url="${url%%:*}"
    echo "$url"
}

# ============================================================================
# ФУНКЦИИ ПРОВЕРКИ СЕТИ
# ============================================================================

ping_host() {
    local host="$1"
    ping -c "$PING_COUNT" -W "$PING_TIMEOUT" "$host" > /dev/null 2>&1
}

get_gateway_ip() {
    local iface="${1:-$WIFI_INTERFACE}"
    local gateway

    gateway=$(ip route show dev "$iface" 2> /dev/null | grep '^default' | awk '{print $3}' | head -n1)
    [ -n "$gateway" ] && {
        echo "$gateway"
        return 0
    }

    gateway=$(ip route 2> /dev/null | grep "^default.*dev $iface" | awk '{print $3}' | head -n1)
    [ -n "$gateway" ] && {
        echo "$gateway"
        return 0
    }

    gateway=$(route -n 2> /dev/null | grep "^0.0.0.0.*$iface" | awk '{print $2}' | head -n1)
    [ -n "$gateway" ] && {
        echo "$gateway"
        return 0
    }

    if [ -f "/tmp/dhcpc.resolv.conf" ]; then
        gateway=$(grep "$iface" /tmp/dhcpc.resolv.conf 2> /dev/null | awk '{print $3}' | head -n1)
        [ -n "$gateway" ] && {
            echo "$gateway"
            return 0
        }
    fi

    if command -v uci > /dev/null 2>&1; then
        local logical="${WIFI_LOGICAL:-$iface}"
        gateway=$(uci_safe_get "network.${logical}.gateway")
        [ -n "$gateway" ] && {
            echo "$gateway"
            return 0
        }
    fi

    gateway=$(ip route 2> /dev/null | grep '^default' | awk '{print $3}' | head -n1)
    [ -n "$gateway" ] && {
        log_warn "Используем общий default gateway: $gateway"
        echo "$gateway"
        return 0
    }

    return 1
}

check_gateway() {
    local attempt=1
    local gateway

    while [ "$attempt" -le "$GATEWAY_CHECK_RETRIES" ]; do
        if gateway=$(get_gateway_ip); then
            if [ -n "$gateway" ]; then
                if ping_host "$gateway"; then
                    log_info "Шлюз $gateway доступен"
                    return 0
                fi
                log_warn "Шлюз $gateway не отвечает (попытка $attempt/$GATEWAY_CHECK_RETRIES)"
            else
                log_warn "Шлюз не найден (попытка $attempt/$GATEWAY_CHECK_RETRIES)"
            fi
        else
            gateway=""
            log_warn "Шлюз не найден (попытка $attempt/$GATEWAY_CHECK_RETRIES)"
        fi
        attempt=$((attempt + 1))
        [ "$attempt" -le "$GATEWAY_CHECK_RETRIES" ] && sleep "$GATEWAY_CHECK_DELAY"
    done

    log_error "Шлюз недоступен после $GATEWAY_CHECK_RETRIES попыток"
    return 1
}

check_internet() {
    local attempt=1
    local server

    while [ "$attempt" -le "$INTERNET_CHECK_RETRIES" ]; do
        for server in $PING_SERVERS; do
            if ping_host "$server"; then
                log_info "Интернет доступен (сервер: $server)"
                return 0
            fi
        done
        attempt=$((attempt + 1))
        [ "$attempt" -le "$INTERNET_CHECK_RETRIES" ] && {
            log_warn "Интернет недоступен, повтор через ${INTERNET_CHECK_DELAY}с (попытка $((attempt - 1))/$INTERNET_CHECK_RETRIES)"
            sleep "$INTERNET_CHECK_DELAY"
        }
    done

    log_warn "Интернет недоступен после $INTERNET_CHECK_RETRIES попыток"
    return 1
}

# ============================================================================
# ФУНКЦИИ УПРАВЛЕНИЯ WiFi
# ============================================================================

interface_exists() {
    local iface="${1:-$WIFI_INTERFACE}"
    ip link show "$iface" > /dev/null 2>&1
}

is_interface_up() {
    local iface="${1:-$WIFI_INTERFACE}"
    ip link show "$iface" 2> /dev/null | grep -q "state UP"
}

restart_wifi_logical() {
    local logical="${1:-$WIFI_LOGICAL}"
    log_info "Перезапуск логического интерфейса: $logical"
    ifdown "$logical" 2> /dev/null || true
    sleep 2
    if ifup "$logical" 2> /dev/null; then
        log_info "Логический интерфейс $logical успешно поднят"
        return 0
    fi
    log_error "Ошибка при поднятии логического интерфейса $logical"
    return 1
}

restart_wifi_physical() {
    local iface="${1:-$WIFI_INTERFACE}"
    log_info "Перезапуск физического интерфейса: $iface"

    if ! interface_exists "$iface"; then
        log_error "Интерфейс $iface не существует"
        return 1
    fi

    ip link set dev "$iface" down 2> /dev/null || true
    sleep 2

    if ! ip link set dev "$iface" up 2> /dev/null; then
        log_error "Ошибка при поднятии интерфейса $iface"
        return 1
    fi

    log_info "Интерфейс $iface успешно поднят"

    local start_time
    start_time=$(date +%s)
    local current_time elapsed gateway

    while true; do
        current_time=$(date +%s)
        elapsed=$((current_time - start_time))
        if [ "$elapsed" -ge "$MAX_WAIT_TIME" ]; then
            log_error "Таймаут ожидания готовности интерфейса ($MAX_WAIT_TIME сек)"
            return 1
        fi
        if is_interface_up "$iface" && ip -4 addr show dev "$iface" | grep -q 'inet '; then
            log_info "Интерфейс $iface получил IP адрес"
            if gateway=$(get_gateway_ip "$iface"); then
                if [ -n "$gateway" ] && ping_host "$gateway"; then
                    log_info "Шлюз $gateway доступен, интерфейс готов"
                    return 0
                fi
            fi
        fi
        sleep 3
    done
}

restart_wifi() {
    log_info "Начало перезапуска WiFi"
    if [ -n "$WIFI_LOGICAL" ] && [ "$WIFI_LOGICAL" != "$WIFI_INTERFACE" ]; then
        if restart_wifi_logical "$WIFI_LOGICAL"; then
            return 0
        fi
        log_warn "Перезапуск через логический интерфейс не удался, пробуем физический"
    fi
    restart_wifi_physical "$WIFI_INTERFACE"
}

# ============================================================================
# LAN И DNS УТИЛИТЫ
# ============================================================================

ensure_lan_interface() {
    if [ -n "$LAN_INTERFACE" ] && ip link show "$LAN_INTERFACE" > /dev/null 2>&1; then
        return 0
    fi

    if command -v uci > /dev/null 2>&1; then
        LAN_INTERFACE=$(uci_safe_get "network.lan.device")
        if [ -z "$LAN_INTERFACE" ]; then
            LAN_INTERFACE=$(uci_safe_get "network.lan.ifname")
            if echo "$LAN_INTERFACE" | grep -q ' '; then
                LAN_INTERFACE=$(echo "$LAN_INTERFACE" | awk '{print $1}')
            fi
        fi
    fi

    [ -z "$LAN_INTERFACE" ] && LAN_INTERFACE="br-lan"

    if ! ip link show "$LAN_INTERFACE" > /dev/null 2>&1; then
        log_warn "LAN интерфейс $LAN_INTERFACE не найден, используем br-lan"
        LAN_INTERFACE="br-lan"
    fi
}

ensure_lan_ip() {
    ensure_lan_interface
    if [ -n "$LAN_IP" ]; then
        return 0
    fi

    LAN_IP=$(ip -4 addr show dev "$LAN_INTERFACE" 2> /dev/null | grep 'inet ' | awk '{print $2}' | cut -d/ -f1 | head -n1)
    if [ -z "$LAN_IP" ] && command -v uci > /dev/null 2>&1; then
        LAN_IP=$(uci_safe_get "network.lan.ipaddr")
    fi

    if [ -z "$LAN_IP" ]; then
        LAN_IP="192.168.1.1"
        log_warn "Не удалось определить LAN IP, используем $LAN_IP"
    fi
}

ensure_lan_ipv6() {
    ensure_lan_interface
    if [ -n "$LAN_IPV6" ]; then
        return 0
    fi

    if command -v ip > /dev/null 2>&1; then
        LAN_IPV6=$(ip -6 addr show dev "$LAN_INTERFACE" scope global 2> /dev/null | awk '{print $2}' | cut -d/ -f1 | head -n1)
    fi

    if [ -z "$LAN_IPV6" ] && command -v uci > /dev/null 2>&1; then
        local tmp
        tmp=$(uci_safe_get "network.lan.ip6addr")
        if [ -n "$tmp" ]; then
            LAN_IPV6="${tmp%%/*}"
        fi
    fi

    if [ -n "$LAN_IPV6" ]; then
        return 0
    fi

    return 1
}

get_upstream_dns() {
    local resolv="/tmp/resolv.conf.d/resolv.conf.auto"
    if [ -f "$resolv" ]; then
        awk '/^nameserver/ {print $2; exit 0}' "$resolv"
        return 0
    fi
    return 1
}

resolve_portal_ipv4() {
    local host="$1"
    local dns ip

    if command -v resolveip > /dev/null 2>&1; then
        ip=$(resolveip "$host" 2> /dev/null | grep -v ':' | head -n1)
        if [ -n "$ip" ]; then
            echo "$ip"
            return 0
        fi
    fi

    dns=""
    if ! dns=$(get_upstream_dns); then
        dns=""
    fi

    if [ -n "$dns" ] && command -v nslookup > /dev/null 2>&1; then
        ip=$(nslookup "$host" "$dns" 2> /dev/null | awk '/^Address[[:space:]]*[0-9]*:/ {print $3} /^Address: / {print $2}' | grep -v ':' | tail -n1)
        if [ -n "$ip" ]; then
            echo "$ip"
            return 0
        fi
    fi

    if command -v nslookup > /dev/null 2>&1; then
        ip=$(nslookup "$host" 2> /dev/null | awk '/^Address[[:space:]]*[0-9]*:/ {print $3} /^Address: / {print $2}' | grep -v ':' | tail -n1)
        if [ -n "$ip" ]; then
            echo "$ip"
            return 0
        fi
    fi

    return 1
}

resolve_portal_ipv6() {
    local host="$1"
    local dns ip

    if command -v resolveip > /dev/null 2>&1; then
        ip=$(resolveip "$host" 2> /dev/null | grep ':' | head -n1)
        if [ -n "$ip" ]; then
            echo "$ip"
            return 0
        fi
    fi

    dns=""
    if ! dns=$(get_upstream_dns); then
        dns=""
    fi

    if [ -n "$dns" ] && command -v nslookup > /dev/null 2>&1; then
        ip=$(nslookup "$host" "$dns" 2> /dev/null | awk '/^Address[[:space:]]*[0-9]*:/ {print $3} /^Address: / {print $2}' | grep ':' | tail -n1)
        if [ -n "$ip" ]; then
            echo "$ip"
            return 0
        fi
    fi

    if command -v nslookup > /dev/null 2>&1; then
        ip=$(nslookup "$host" 2> /dev/null | awk '/^Address[[:space:]]*[0-9]*:/ {print $3} /^Address: / {print $2}' | grep ':' | tail -n1)
        if [ -n "$ip" ]; then
            echo "$ip"
            return 0
        fi
    fi

    return 1
}

# ============================================================================
# ПОИСК CAPTIVE-ПОРТАЛА
# ============================================================================

extract_meta_refresh_url() {
    local file="$1"
    local line lower candidate

    while IFS= read -r line; do
        lower=$(echo "$line" | tr '[:upper:]' '[:lower:]')
        case "$lower" in
            *http-equiv*refresh*)
                candidate=$(echo "$line" | sed -n 's/.*[Uu][Rr][Ll]=["'"'"']\([^"'"'"' >]*\).*/\1/p')
                [ -n "$candidate" ] && {
                    echo "$candidate"
                    return 0
                }
                ;;
        esac
    done < "$file"
    return 1
}

extract_first_href() {
    local file="$1"
    local candidate

    while IFS= read -r line; do
        echo "$line" | grep -qi "href" || continue
        candidate=$(echo "$line" | sed -n 's/.*href=["'"'"']\([^"'"'"'# >]*\).*/\1/p' | head -n1)
        if [ -n "$candidate" ] && echo "$candidate" | grep -q '^http'; then
            echo "$candidate"
            return 0
        fi
    done < "$file"
    return 1
}

detect_captive_portal() {
    local url
    local header_file body_file status location candidate portal_url host

    if ! command -v curl > /dev/null 2>&1; then
        log_error "curl не найден, невозможно выполнить проверку captive-портала"
        return 1
    fi

    header_file=$(mktemp /tmp/captive_hdr.XXXXXX) || return 1
    body_file=$(mktemp /tmp/captive_body.XXXXXX) || {
        rm -f "$header_file"
        return 1
    }

    CAPTIVE_PORTAL_URL=""
    CAPTIVE_PORTAL_HOST=""

    for url in $CAPTIVE_CHECK_URLS; do
        log_info "Проверка captive-портала через $url"
        portal_url=""
        if ! curl -sS -m "$CAPTIVE_CURL_TIMEOUT" -D "$header_file" -o "$body_file" "$url" > /dev/null 2>&1; then
            log_warn "curl для $url завершился ошибкой"
            continue
        fi

        status=$(head -n1 "$header_file" | awk '{print $2}')
        location=$(grep -i '^Location:' "$header_file" | tail -n1 | cut -d' ' -f2-)
        location=$(trim "$location")

        if [ "$status" = "204" ]; then
            rm -f "$header_file" "$body_file"
            return 1
        fi

        if [ "$status" = "200" ]; then
            if grep -qi '^success' "$body_file"; then
                rm -f "$header_file" "$body_file"
                return 1
            fi
        fi

        if [ -n "$location" ]; then
            if echo "$location" | grep -q '^http'; then
                portal_url="$location"
            else
                portal_url=$(normalize_url "$location" "$url")
            fi
        else
            candidate=""
            if candidate=$(extract_meta_refresh_url "$body_file"); then
                if [ -n "$candidate" ]; then
                    portal_url=$(normalize_url "$candidate" "$url")
                fi
            fi
            if [ -z "$portal_url" ]; then
                candidate=""
                if candidate=$(extract_first_href "$body_file"); then
                    if [ -n "$candidate" ]; then
                        portal_url=$(normalize_url "$candidate" "$url")
                    fi
                fi
            fi
        fi

        if [ -n "$portal_url" ]; then
            host=$(extract_host_from_url "$portal_url")
            if [ -n "$host" ]; then
                CAPTIVE_PORTAL_URL="$portal_url"
                CAPTIVE_PORTAL_HOST="$host"
                rm -f "$header_file" "$body_file"
                log_info "Обнаружен captive-портал: $CAPTIVE_PORTAL_URL"
                return 0
            fi
        fi
    done

    rm -f "$header_file" "$body_file"
    return 1
}

# ============================================================================
# DNS И HTTP ПЕРЕХВАТ
# ============================================================================

write_dnsmasq_intercept() {
    local portal_host="$1"
    local portal_ip4="$2"
    local portal_ip6="$3"

    ensure_lan_ip
    ensure_lan_ipv6 || true

    mkdir -p "$DNSMASQ_CAPTIVE_DIR"

    {
        echo "# Captive portal intercept"
        echo "# generated $(date)"
        echo "address=/#/$LAN_IP"
        if [ "$HTTPD_IPV6_READY" = "1" ] && [ -n "$LAN_IPV6" ]; then
            echo "address=/#/$LAN_IPV6"
        fi
        echo "local-ttl=0"
        echo "min-cache-ttl=0"
        echo "max-cache-ttl=0"
        echo "no-negcache"
        if [ -n "$portal_host" ] && [ -n "$portal_ip4" ]; then
            echo "address=/$portal_host/$portal_ip4"
        fi
        if [ "$HTTPD_IPV6_READY" = "1" ] && [ -n "$portal_host" ] && [ -n "$portal_ip6" ]; then
            echo "address=/$portal_host/$portal_ip6"
        fi
    } > "$DNSMASQ_CAPTIVE_CONF"

    if /etc/init.d/dnsmasq reload > /dev/null 2>&1; then
        log_info "dnsmasq перезагружен с конфигурацией перехвата"
    else
        log_warn "Не удалось выполнить reload dnsmasq"
    fi
}

remove_dns_intercept() {
    if [ -f "$DNSMASQ_CAPTIVE_CONF" ]; then
        rm -f "$DNSMASQ_CAPTIVE_CONF"
        if /etc/init.d/dnsmasq reload > /dev/null 2>&1; then
            log_info "dnsmasq конфигурация перехвата удалена"
        fi
    fi
}

start_captive_httpd() {
    local portal_url="$1"
    local pid
    local attempt
    local started

    stop_captive_httpd
    HTTPD_IPV6_READY=0
    ensure_lan_ip
    ensure_lan_ipv6 || true

    mkdir -p "$HTTPD_ROOT"

    cat > "$HTTPD_INDEX" << EOF_HTML
<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Captive Portal Redirect</title>
<meta http-equiv="refresh" content="0; url=$portal_url">
<style>body{font-family:sans-serif;text-align:center;margin-top:40px;}</style>
<script>window.location.replace('$portal_url');</script>
</head>
<body>
<p>Перенаправление на страницу авторизации...</p>
<p><a href="$portal_url">Открыть портал вручную</a></p>
</body>
</html>
EOF_HTML

    busybox httpd -f -p "0.0.0.0:$HTTPD_PORT" -p "[::]:$HTTPD_PORT" -h "$HTTPD_ROOT" > /dev/null 2>&1 &
    pid=$!
    started=0
    for attempt in 1 2 3; do
        if kill -0 "$pid" 2> /dev/null; then
            started=1
            break
        fi
        sleep 1
    done

    if [ "$started" = "1" ]; then
        HTTPD_IPV6_READY=1
        echo "$pid" > "$HTTPD_PIDFILE"
        log_info "Запущен busybox httpd (PID $pid) для редиректа (IPv4/IPv6)"
        return 0
    fi

    wait "$pid" 2> /dev/null || true
    log_warn "Не удалось запустить busybox httpd с IPv6, пробуем только IPv4"

    busybox httpd -f -p "0.0.0.0:$HTTPD_PORT" -h "$HTTPD_ROOT" > /dev/null 2>&1 &
    pid=$!
    started=0
    for attempt in 1 2 3; do
        if kill -0 "$pid" 2> /dev/null; then
            started=1
            break
        fi
        sleep 1
    done

    if [ "$started" = "1" ]; then
        HTTPD_IPV6_READY=0
        echo "$pid" > "$HTTPD_PIDFILE"
        log_info "Запущен busybox httpd (PID $pid) для редиректа (IPv4)"
        return 0
    fi

    wait "$pid" 2> /dev/null || true
    log_error "Не удалось запустить busybox httpd для captive-портала"
    rm -f "$HTTPD_PIDFILE"
    return 1
}

stop_captive_httpd() {
    if [ -f "$HTTPD_PIDFILE" ]; then
        local pid
        pid=$(cat "$HTTPD_PIDFILE")
        if [ -n "$pid" ] && kill -0 "$pid" 2> /dev/null; then
            kill "$pid" > /dev/null 2>&1
            if ! wait "$pid" 2> /dev/null; then
                :
            fi
            log_info "Остановлен busybox httpd (PID $pid)"
        fi
        rm -f "$HTTPD_PIDFILE"
    fi
    HTTPD_IPV6_READY=0
    rm -rf "$HTTPD_ROOT"
}

detect_firewall_backend() {
    if [ "$FIREWALL_BACKEND_DETECTED" = "1" ] && [ -n "$FIREWALL_BACKEND" ]; then
        return 0
    fi

    local requested=""
    if [ -n "${CAPTIVE_FIREWALL_BACKEND:-}" ]; then
        requested=$(printf '%s' "$CAPTIVE_FIREWALL_BACKEND" | tr '[:upper:]' '[:lower:]')
    elif [ -n "$REQUESTED_FIREWALL_BACKEND" ]; then
        requested=$(printf '%s' "$REQUESTED_FIREWALL_BACKEND" | tr '[:upper:]' '[:lower:]')
    fi

    case "$requested" in
        nft | nftables | fw4)
            if command -v nft > /dev/null 2>&1; then
                FIREWALL_BACKEND="nftables"
            else
                log_warn "Запрошен backend nftables, но утилита nft недоступна; используем iptables"
                FIREWALL_BACKEND="iptables"
            fi
            ;;
        ipt | iptables | fw3)
            FIREWALL_BACKEND="iptables"
            ;;
        "" | auto)
            if command -v fw4 > /dev/null 2>&1 && command -v nft > /dev/null 2>&1; then
                FIREWALL_BACKEND="nftables"
            else
                FIREWALL_BACKEND="iptables"
            fi
            ;;
        *)
            log_warn "Неизвестное значение firewall_backend: $requested, используем автоопределение"
            if command -v fw4 > /dev/null 2>&1 && command -v nft > /dev/null 2>&1; then
                FIREWALL_BACKEND="nftables"
            else
                FIREWALL_BACKEND="iptables"
            fi
            ;;
    esac

    FIREWALL_BACKEND_DETECTED=1
    log_info "Используется firewall backend: $FIREWALL_BACKEND"
}

setup_firewall_redirects() {
    local portal_ip4="$1"
    local portal_ip6="$2"

    detect_firewall_backend

    case "$FIREWALL_BACKEND" in
        nftables)
            setup_firewall_redirects_nft "$portal_ip4" "$portal_ip6"
            ;;
        *)
            setup_firewall_redirects_iptables "$portal_ip4" "$portal_ip6"
            ;;
    esac
}

cleanup_firewall_redirects() {
    if [ "$FIREWALL_BACKEND_DETECTED" != "1" ]; then
        cleanup_firewall_redirects_nft
        cleanup_firewall_redirects_iptables
        return 0
    fi

    case "$FIREWALL_BACKEND" in
        nftables)
            cleanup_firewall_redirects_nft
            ;;
        *)
            cleanup_firewall_redirects_iptables
            ;;
    esac
}

setup_firewall_redirects_iptables() {
    local portal_ip4="$1"
    local portal_ip6="$2"

    ensure_lan_interface
    ensure_lan_ip

    if ! command -v iptables > /dev/null 2>&1; then
        log_error "iptables не найден, невозможно настроить перехват"
        return 1
    fi

    if ! iptables -t nat -L "$CAPTIVE_NAT_CHAIN" > /dev/null 2>&1; then
        if ! iptables -t nat -N "$CAPTIVE_NAT_CHAIN" > /dev/null 2>&1; then
            log_error "Не удалось создать цепочку $CAPTIVE_NAT_CHAIN в iptables"
            return 1
        fi
    else
        iptables -t nat -F "$CAPTIVE_NAT_CHAIN"
    fi

    if [ -n "$portal_ip4" ]; then
        iptables -t nat -A "$CAPTIVE_NAT_CHAIN" -d "$portal_ip4" -p tcp --dport 80 -j RETURN -m comment --comment "captive-http-bypass-v4"
    fi

    iptables -t nat -A "$CAPTIVE_NAT_CHAIN" -p tcp --dport 80 -j DNAT --to-destination "$LAN_IP:$HTTPD_PORT" -m comment --comment "captive-http-redirect-v4"

    if ! iptables -t nat -C PREROUTING -i "$LAN_INTERFACE" -p tcp --dport 80 -j "$CAPTIVE_NAT_CHAIN" 2> /dev/null; then
        iptables -t nat -I PREROUTING 1 -i "$LAN_INTERFACE" -p tcp --dport 80 -j "$CAPTIVE_NAT_CHAIN" -m comment --comment "captive-http-intercept-v4"
    fi

    if ! iptables -t nat -L "$CAPTIVE_DNS_CHAIN" > /dev/null 2>&1; then
        if ! iptables -t nat -N "$CAPTIVE_DNS_CHAIN" > /dev/null 2>&1; then
            log_error "Не удалось создать цепочку $CAPTIVE_DNS_CHAIN в iptables"
            return 1
        fi
    else
        iptables -t nat -F "$CAPTIVE_DNS_CHAIN"
    fi

    iptables -t nat -A "$CAPTIVE_DNS_CHAIN" -p udp --dport 53 -j DNAT --to-destination "$LAN_IP" -m comment --comment "captive-dns-redirect-udp-v4"
    iptables -t nat -A "$CAPTIVE_DNS_CHAIN" -p tcp --dport 53 -j DNAT --to-destination "$LAN_IP" -m comment --comment "captive-dns-redirect-tcp-v4"

    if ! iptables -t nat -C PREROUTING -i "$LAN_INTERFACE" -p udp --dport 53 -j "$CAPTIVE_DNS_CHAIN" 2> /dev/null; then
        iptables -t nat -I PREROUTING 1 -i "$LAN_INTERFACE" -p udp --dport 53 -j "$CAPTIVE_DNS_CHAIN" -m comment --comment "captive-dns-intercept-udp-v4"
    fi

    if ! iptables -t nat -C PREROUTING -i "$LAN_INTERFACE" -p tcp --dport 53 -j "$CAPTIVE_DNS_CHAIN" 2> /dev/null; then
        iptables -t nat -I PREROUTING 1 -i "$LAN_INTERFACE" -p tcp --dport 53 -j "$CAPTIVE_DNS_CHAIN" -m comment --comment "captive-dns-intercept-tcp-v4"
    fi

    if [ "$HTTPD_IPV6_READY" = "1" ]; then
        if command -v ip6tables > /dev/null 2>&1; then
            if ensure_lan_ipv6; then
                local ipv6_chain_ready=1
                if ip6tables -t nat -L "$CAPTIVE_NAT_CHAIN" > /dev/null 2>&1; then
                    ip6tables -t nat -F "$CAPTIVE_NAT_CHAIN" > /dev/null 2>&1 || true
                elif ip6tables -t nat -N "$CAPTIVE_NAT_CHAIN" > /dev/null 2>&1; then
                    :
                else
                    ipv6_chain_ready=0
                    log_warn "ip6tables nat недоступен, пропускаем IPv6 HTTP перехват"
                fi

                if [ "$ipv6_chain_ready" = "1" ]; then
                    if [ -n "$portal_ip6" ]; then
                        if ! ip6tables -t nat -A "$CAPTIVE_NAT_CHAIN" -d "$portal_ip6" -p tcp --dport 80 -j RETURN -m comment --comment "captive-http-bypass-v6"; then
                            log_warn "Не удалось добавить IPv6 правило обхода портала в ip6tables"
                        fi
                    fi

                    local lan_ipv6_target="[$LAN_IPV6]:$HTTPD_PORT"
                    if ! ip6tables -t nat -A "$CAPTIVE_NAT_CHAIN" -p tcp --dport 80 -j DNAT --to-destination "$lan_ipv6_target" -m comment --comment "captive-http-redirect-v6"; then
                        log_warn "Не удалось добавить IPv6 HTTP DNAT в ip6tables"
                    fi

                    if ! ip6tables -t nat -C PREROUTING -i "$LAN_INTERFACE" -p tcp --dport 80 -j "$CAPTIVE_NAT_CHAIN" 2> /dev/null; then
                        if ! ip6tables -t nat -I PREROUTING 1 -i "$LAN_INTERFACE" -p tcp --dport 80 -j "$CAPTIVE_NAT_CHAIN" -m comment --comment "captive-http-intercept-v6"; then
                            log_warn "Не удалось добавить IPv6 правило перехвата HTTP в ip6tables"
                        fi
                    fi
                fi

                local ipv6_dns_chain_ready=1
                if ip6tables -t nat -L "$CAPTIVE_DNS_CHAIN" > /dev/null 2>&1; then
                    ip6tables -t nat -F "$CAPTIVE_DNS_CHAIN" > /dev/null 2>&1 || true
                elif ip6tables -t nat -N "$CAPTIVE_DNS_CHAIN" > /dev/null 2>&1; then
                    :
                else
                    ipv6_dns_chain_ready=0
                    log_warn "ip6tables nat недоступен, пропускаем IPv6 DNS перехват"
                fi

                if [ "$ipv6_dns_chain_ready" = "1" ]; then
                    local lan_ipv6_dns="[$LAN_IPV6]"
                    if ! ip6tables -t nat -A "$CAPTIVE_DNS_CHAIN" -p udp --dport 53 -j DNAT --to-destination "$lan_ipv6_dns" -m comment --comment "captive-dns-redirect-udp-v6"; then
                        log_warn "Не удалось добавить IPv6 UDP DNS DNAT в ip6tables"
                    fi
                    if ! ip6tables -t nat -A "$CAPTIVE_DNS_CHAIN" -p tcp --dport 53 -j DNAT --to-destination "$lan_ipv6_dns" -m comment --comment "captive-dns-redirect-tcp-v6"; then
                        log_warn "Не удалось добавить IPv6 TCP DNS DNAT в ip6tables"
                    fi

                    if ! ip6tables -t nat -C PREROUTING -i "$LAN_INTERFACE" -p udp --dport 53 -j "$CAPTIVE_DNS_CHAIN" 2> /dev/null; then
                        if ! ip6tables -t nat -I PREROUTING 1 -i "$LAN_INTERFACE" -p udp --dport 53 -j "$CAPTIVE_DNS_CHAIN" -m comment --comment "captive-dns-intercept-udp-v6"; then
                            log_warn "Не удалось добавить IPv6 правило перехвата UDP DNS в ip6tables"
                        fi
                    fi

                    if ! ip6tables -t nat -C PREROUTING -i "$LAN_INTERFACE" -p tcp --dport 53 -j "$CAPTIVE_DNS_CHAIN" 2> /dev/null; then
                        if ! ip6tables -t nat -I PREROUTING 1 -i "$LAN_INTERFACE" -p tcp --dport 53 -j "$CAPTIVE_DNS_CHAIN" -m comment --comment "captive-dns-intercept-tcp-v6"; then
                            log_warn "Не удалось добавить IPv6 правило перехвата TCP DNS в ip6tables"
                        fi
                    fi
                fi
            else
                log_warn "IPv6 адрес LAN не найден, пропускаем настройки ip6tables"
            fi
        else
            log_warn "ip6tables не найден, пропускаем IPv6 редирект"
        fi
    else
        if [ -n "$LAN_IPV6" ] || [ -n "$portal_ip6" ]; then
            log_warn "HTTP сервер не слушает IPv6, пропускаем настройки ip6tables"
        fi
    fi

    log_info "iptables настроен для перехвата HTTP и DNS на интерфейсе $LAN_INTERFACE"
    return 0
}

cleanup_firewall_redirects_iptables() {
    ensure_lan_interface

    if command -v iptables > /dev/null 2>&1; then
        while iptables -t nat -C PREROUTING -i "$LAN_INTERFACE" -p tcp --dport 80 -j "$CAPTIVE_NAT_CHAIN" 2> /dev/null; do
            iptables -t nat -D PREROUTING -i "$LAN_INTERFACE" -p tcp --dport 80 -j "$CAPTIVE_NAT_CHAIN"
        done
        while iptables -t nat -C PREROUTING -i "$LAN_INTERFACE" -p udp --dport 53 -j "$CAPTIVE_DNS_CHAIN" 2> /dev/null; do
            iptables -t nat -D PREROUTING -i "$LAN_INTERFACE" -p udp --dport 53 -j "$CAPTIVE_DNS_CHAIN"
        done
        while iptables -t nat -C PREROUTING -i "$LAN_INTERFACE" -p tcp --dport 53 -j "$CAPTIVE_DNS_CHAIN" 2> /dev/null; do
            iptables -t nat -D PREROUTING -i "$LAN_INTERFACE" -p tcp --dport 53 -j "$CAPTIVE_DNS_CHAIN"
        done
        iptables -t nat -F "$CAPTIVE_NAT_CHAIN" 2> /dev/null || true
        iptables -t nat -X "$CAPTIVE_NAT_CHAIN" 2> /dev/null || true
        iptables -t nat -F "$CAPTIVE_DNS_CHAIN" 2> /dev/null || true
        iptables -t nat -X "$CAPTIVE_DNS_CHAIN" 2> /dev/null || true
    fi

    if command -v ip6tables > /dev/null 2>&1; then
        while ip6tables -t nat -C PREROUTING -i "$LAN_INTERFACE" -p tcp --dport 80 -j "$CAPTIVE_NAT_CHAIN" 2> /dev/null; do
            ip6tables -t nat -D PREROUTING -i "$LAN_INTERFACE" -p tcp --dport 80 -j "$CAPTIVE_NAT_CHAIN" || true
        done
        while ip6tables -t nat -C PREROUTING -i "$LAN_INTERFACE" -p udp --dport 53 -j "$CAPTIVE_DNS_CHAIN" 2> /dev/null; do
            ip6tables -t nat -D PREROUTING -i "$LAN_INTERFACE" -p udp --dport 53 -j "$CAPTIVE_DNS_CHAIN" || true
        done
        while ip6tables -t nat -C PREROUTING -i "$LAN_INTERFACE" -p tcp --dport 53 -j "$CAPTIVE_DNS_CHAIN" 2> /dev/null; do
            ip6tables -t nat -D PREROUTING -i "$LAN_INTERFACE" -p tcp --dport 53 -j "$CAPTIVE_DNS_CHAIN" || true
        done
        ip6tables -t nat -F "$CAPTIVE_NAT_CHAIN" 2> /dev/null || true
        ip6tables -t nat -X "$CAPTIVE_NAT_CHAIN" 2> /dev/null || true
        ip6tables -t nat -F "$CAPTIVE_DNS_CHAIN" 2> /dev/null || true
        ip6tables -t nat -X "$CAPTIVE_DNS_CHAIN" 2> /dev/null || true
    fi
}

setup_firewall_redirects_nft() {
    local portal_ip4="$1"
    local portal_ip6="$2"

    ensure_lan_interface
    ensure_lan_ip
    ensure_lan_ipv6 || true

    local nft_ipv6_enabled=0
    if [ "$HTTPD_IPV6_READY" = "1" ] && [ -n "$LAN_IPV6" ]; then
        nft_ipv6_enabled=1
    fi

    if ! command -v nft > /dev/null 2>&1; then
        log_error "nft не найден, невозможно настроить перехват"
        return 1
    fi

    if ! nft list table inet "$NFT_TABLE_NAME" > /dev/null 2>&1; then
        if ! nft add table inet "$NFT_TABLE_NAME" > /dev/null 2>&1; then
            log_error "Не удалось создать таблицу nftables $NFT_TABLE_NAME"
            return 1
        fi
    fi

    if ! nft list chain inet "$NFT_TABLE_NAME" "$NFT_CHAIN_NAME" > /dev/null 2>&1; then
        if ! nft add chain inet "$NFT_TABLE_NAME" "$NFT_CHAIN_NAME" '{ type nat hook prerouting priority dstnat; policy accept; }' > /dev/null 2>&1; then
            log_error "Не удалось создать цепочку nftables $NFT_CHAIN_NAME"
            return 1
        fi
    fi

    if ! nft flush chain inet "$NFT_TABLE_NAME" "$NFT_CHAIN_NAME" > /dev/null 2>&1; then
        log_error "Не удалось очистить цепочку nftables $NFT_CHAIN_NAME"
        return 1
    fi

    if [ -n "$portal_ip4" ]; then
        nft add rule inet "$NFT_TABLE_NAME" "$NFT_CHAIN_NAME" iifname "$LAN_INTERFACE" ip daddr "$portal_ip4" tcp dport 80 return comment "captive-http-bypass-v4" > /dev/null 2>&1 || log_warn "Не удалось добавить правило обхода IPv4 портала в nftables"
    fi

    if [ "$nft_ipv6_enabled" = "1" ] && [ -n "$portal_ip6" ]; then
        nft add rule inet "$NFT_TABLE_NAME" "$NFT_CHAIN_NAME" iifname "$LAN_INTERFACE" ip6 daddr "$portal_ip6" tcp dport 80 return comment "captive-http-bypass-v6" > /dev/null 2>&1 || log_warn "Не удалось добавить правило обхода IPv6 портала в nftables"
    elif [ -n "$portal_ip6" ] && [ "$HTTPD_IPV6_READY" != "1" ]; then
        log_warn "HTTP сервер не слушает IPv6, пропускаем правило обхода портала в nftables"
    fi

    if ! nft add rule inet "$NFT_TABLE_NAME" "$NFT_CHAIN_NAME" iifname "$LAN_INTERFACE" meta nfproto ipv4 tcp dport 80 dnat to "$LAN_IP:$HTTPD_PORT" comment "captive-http-redirect-v4" > /dev/null 2>&1; then
        log_error "Не удалось добавить правило IPv4 HTTP DNAT в nftables"
        return 1
    fi

    if [ "$nft_ipv6_enabled" = "1" ]; then
        nft add rule inet "$NFT_TABLE_NAME" "$NFT_CHAIN_NAME" iifname "$LAN_INTERFACE" meta nfproto ipv6 tcp dport 80 dnat to "[$LAN_IPV6]:$HTTPD_PORT" comment "captive-http-redirect-v6" > /dev/null 2>&1 || log_warn "Не удалось добавить правило IPv6 HTTP DNAT в nftables"
    else
        if [ "$HTTPD_IPV6_READY" = "1" ] && [ -z "$LAN_IPV6" ]; then
            log_warn "IPv6 адрес LAN не найден, пропускаем IPv6 HTTP DNAT в nftables"
        elif [ "$HTTPD_IPV6_READY" != "1" ] && [ -n "$LAN_IPV6" ]; then
            log_warn "HTTP сервер не слушает IPv6, пропускаем IPv6 HTTP DNAT в nftables"
        fi
    fi

    if ! nft add rule inet "$NFT_TABLE_NAME" "$NFT_CHAIN_NAME" iifname "$LAN_INTERFACE" meta nfproto ipv4 udp dport 53 dnat to "$LAN_IP" comment "captive-dns-redirect-udp-v4" > /dev/null 2>&1; then
        log_error "Не удалось добавить правило IPv4 UDP DNS DNAT в nftables"
        return 1
    fi

    if ! nft add rule inet "$NFT_TABLE_NAME" "$NFT_CHAIN_NAME" iifname "$LAN_INTERFACE" meta nfproto ipv4 tcp dport 53 dnat to "$LAN_IP" comment "captive-dns-redirect-tcp-v4" > /dev/null 2>&1; then
        log_error "Не удалось добавить правило IPv4 TCP DNS DNAT в nftables"
        return 1
    fi

    if [ "$nft_ipv6_enabled" = "1" ]; then
        nft add rule inet "$NFT_TABLE_NAME" "$NFT_CHAIN_NAME" iifname "$LAN_INTERFACE" meta nfproto ipv6 udp dport 53 dnat to "[$LAN_IPV6]" comment "captive-dns-redirect-udp-v6" > /dev/null 2>&1 || log_warn "Не удалось добавить правило IPv6 UDP DNS DNAT в nftables"
        nft add rule inet "$NFT_TABLE_NAME" "$NFT_CHAIN_NAME" iifname "$LAN_INTERFACE" meta nfproto ipv6 tcp dport 53 dnat to "[$LAN_IPV6]" comment "captive-dns-redirect-tcp-v6" > /dev/null 2>&1 || log_warn "Не удалось добавить правило IPv6 TCP DNS DNAT в nftables"
    else
        if [ "$HTTPD_IPV6_READY" = "1" ] && [ -z "$LAN_IPV6" ]; then
            log_warn "IPv6 адрес LAN не найден, пропускаем IPv6 DNS DNAT в nftables"
        elif [ "$HTTPD_IPV6_READY" != "1" ] && [ -n "$LAN_IPV6" ]; then
            log_warn "HTTP сервер не слушает IPv6, пропускаем IPv6 DNS DNAT в nftables"
        fi
    fi

    log_info "nftables настроен для перехвата HTTP и DNS на интерфейсе $LAN_INTERFACE"
    return 0
}

cleanup_firewall_redirects_nft() {
    if ! command -v nft > /dev/null 2>&1; then
        return 0
    fi

    if nft list table inet "$NFT_TABLE_NAME" > /dev/null 2>&1; then
        if nft delete table inet "$NFT_TABLE_NAME" > /dev/null 2>&1; then
            log_info "Удалена таблица nftables $NFT_TABLE_NAME"
        else
            nft flush table inet "$NFT_TABLE_NAME" > /dev/null 2>&1 || true
        fi
    fi
}

setup_captive_intercept() {
    local portal_url="$1"
    local portal_host="$2"
    local portal_ip4="$3"
    local portal_ip6="$4"

    ensure_lan_ip

    if [ "$CAPTIVE_ACTIVE" = "1" ] && [ "$ACTIVE_PORTAL_URL" = "$portal_url" ]; then
        log_info "Перехват уже активен для $portal_url"
        return 0
    fi

    if [ "$CAPTIVE_ACTIVE" = "1" ]; then
        cleanup_captive_intercept
    fi

    if ! start_captive_httpd "$portal_url"; then
        remove_dns_intercept
        return 1
    fi

    write_dnsmasq_intercept "$portal_host" "$portal_ip4" "$portal_ip6"

    if ! setup_firewall_redirects "$portal_ip4" "$portal_ip6"; then
        cleanup_firewall_redirects
        stop_captive_httpd
        remove_dns_intercept
        return 1
    fi

    CAPTIVE_ACTIVE=1
    ACTIVE_PORTAL_URL="$portal_url"
    ACTIVE_PORTAL_HOST="$portal_host"
    ACTIVE_PORTAL_IP="$portal_ip4"
    ACTIVE_PORTAL_IP6="$portal_ip6"

    log_info "Перехват captive-портала включен"
    return 0
}

cleanup_captive_intercept() {
    if [ "$CAPTIVE_ACTIVE" = "1" ] || [ -f "$DNSMASQ_CAPTIVE_CONF" ] || [ -f "$HTTPD_PIDFILE" ]; then
        if [ -n "$ACTIVE_PORTAL_URL" ]; then
            log_info "Очистка перехвата captive-портала для $ACTIVE_PORTAL_URL (host: ${ACTIVE_PORTAL_HOST:--}, ipv4: ${ACTIVE_PORTAL_IP:--}, ipv6: ${ACTIVE_PORTAL_IP6:--})"
        else
            log_info "Очистка перехвата captive-портала"
        fi
    fi

    cleanup_firewall_redirects
    stop_captive_httpd
    remove_dns_intercept

    CAPTIVE_ACTIVE=0
    ACTIVE_PORTAL_URL=""
    ACTIVE_PORTAL_HOST=""
    ACTIVE_PORTAL_IP=""
    ACTIVE_PORTAL_IP6=""
}

# ============================================================================
# ОСНОВНАЯ ЛОГИКА
# ============================================================================

wait_for_internet_after_intercept() {
    local elapsed=0

    while [ "$elapsed" -lt "$CAPTIVE_RECOVERY_TIMEOUT" ]; do
        sleep "$CAPTIVE_RECHECK_DELAY"
        elapsed=$((elapsed + CAPTIVE_RECHECK_DELAY))
        if check_internet; then
            log_info "Интернет доступен, отключаем перехват"
            cleanup_captive_intercept
            return 0
        fi
        log_info "Интернет все еще недоступен (ожидание ${elapsed}/${CAPTIVE_RECOVERY_TIMEOUT}с)"
    done

    log_warn "Интернет не восстановился за $CAPTIVE_RECOVERY_TIMEOUT секунд"
    return 1
}

check_and_fix_connection() {
    log_info "=== Проверка подключения ==="

    ensure_lan_ip

    if check_internet; then
        if [ "$CAPTIVE_ACTIVE" = "1" ]; then
            cleanup_captive_intercept
        fi
        return 0
    fi

    log_warn "Интернет недоступен, пробуем диагностировать captive-портал"

    if detect_captive_portal; then
        local portal_ip4=""
        local portal_ip6=""
        if [ -n "$CAPTIVE_PORTAL_HOST" ]; then
            if portal_ip4=$(resolve_portal_ipv4 "$CAPTIVE_PORTAL_HOST"); then
                if [ -n "$portal_ip4" ]; then
                    log_info "IPv4 адрес портала: $portal_ip4"
                fi
            else
                portal_ip4=""
            fi
            if portal_ip6=$(resolve_portal_ipv6 "$CAPTIVE_PORTAL_HOST"); then
                if [ -n "$portal_ip6" ]; then
                    log_info "IPv6 адрес портала: $portal_ip6"
                fi
            else
                portal_ip6=""
            fi
        fi
        if setup_captive_intercept "$CAPTIVE_PORTAL_URL" "$CAPTIVE_PORTAL_HOST" "$portal_ip4" "$portal_ip6"; then
            if wait_for_internet_after_intercept; then
                return 0
            fi
            return 1
        fi
        log_warn "Не удалось настроить перехват captive-портала"
        return 1
    fi

    log_warn "Captive-портал не обнаружен, пробуем перезапустить WiFi"
    if restart_wifi; then
        if check_internet; then
            cleanup_captive_intercept
            return 0
        fi
    fi

    log_warn "Сеть остаётся недоступной после всех действий"
    return 1
}

monitor_mode() {
    log_info "Запуск в режиме мониторинга (интервал: ${MONITOR_INTERVAL}с)"
    while true; do
        if ! check_and_fix_connection; then
            log_warn "Проверка подключения завершилась с ошибкой"
        fi
        log_info "Следующая проверка через ${MONITOR_INTERVAL}с"
        sleep "$MONITOR_INTERVAL"
    done
}

oneshot_mode() {
    log_info "Запуск в режиме однократной проверки"
    if check_and_fix_connection; then
        exit 0
    fi
    exit 1
}

# ============================================================================
# ТОЧКА ВХОДА
# ============================================================================

show_usage() {
    cat << EOF
Использование: $0 [ОПЦИИ]

Опции:
  -m, --monitor     Режим мониторинга (бесконечный цикл)
  -o, --oneshot     Однократная проверка и выход
  -i, --interface   WiFi интерфейс (по умолчанию: $WIFI_INTERFACE)
  -l, --logical     Логический интерфейс OpenWRT (по умолчанию: $WIFI_LOGICAL)
  -t, --interval    Интервал мониторинга в секундах (по умолчанию: $MONITOR_INTERVAL)
  -h, --help        Показать эту справку

Переменные окружения:
  WIFI_INTERFACE    Физический WiFi интерфейс
  WIFI_LOGICAL      Логический интерфейс OpenWRT
  LAN_INTERFACE     LAN интерфейс (определяется автоматически)
  LAN_IP            LAN IP адрес роутера (определяется автоматически)
  MONITOR_INTERVAL  Интервал проверки в секундах
EOF
}

load_uci_config

MODE="$DEFAULT_MODE"

while [ $# -gt 0 ]; do
    case "$1" in
        -m | --monitor)
            MODE="monitor"
            shift
            ;;
        -o | --oneshot)
            MODE="oneshot"
            shift
            ;;
        -i | --interface)
            WIFI_INTERFACE="$2"
            shift 2
            ;;
        -l | --logical)
            WIFI_LOGICAL="$2"
            shift 2
            ;;
        -t | --interval)
            MONITOR_INTERVAL="$2"
            shift 2
            ;;
        -h | --help)
            show_usage
            exit 0
            ;;
        *)
            echo "Неизвестная опция: $1" >&2
            show_usage
            exit 1
            ;;
    esac
done

if [ "$(id -u)" -ne 0 ]; then
    log_error "Скрипт требует прав root"
    exit 1
fi

trap 'cleanup_captive_intercept' EXIT
trap 'exit 0' INT TERM

case "$MODE" in
    monitor)
        monitor_mode
        ;;
    oneshot)
        oneshot_mode
        ;;
    *)
        log_error "Неизвестный режим: $MODE"
        exit 1
        ;;
esac
