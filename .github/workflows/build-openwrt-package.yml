name: Build OpenWrt Package

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read

defaults:
  run:
    shell: bash

env:
  OPENWRT_VERSION: "23.05.3"
  SDK_CHECKSUM: "f90d60c7a00a50a1c80807fb32fd4c12bed1fb65871328f3c2171caf9b711254"

jobs:
  build:
    name: Build OpenWrt package
    runs-on: ubuntu-latest

    steps:
      - name: Check out repository
        uses: actions/checkout@v5

      - name: Download and extract OpenWrt SDK from GitHub CDN
        run: |
          set -euo pipefail
          SDK_VERSION="${{ env.OPENWRT_VERSION }}"
          SDK_FILE="openwrt-sdk-${SDK_VERSION}-x86-64_gcc-12.3.0_musl.Linux-x86_64.tar.xz"
          SDK_DIR="openwrt-sdk-${SDK_VERSION}-x86-64_gcc-12.3.0_musl.Linux-x86_64"
          PACKAGE_NAME="openwrt-captive-monitor"
          
          # Export for subsequent steps
          echo "SDK_DIR=$SDK_DIR" >> "$GITHUB_ENV"
          echo "PACKAGE_NAME=$PACKAGE_NAME" >> "$GITHUB_ENV"
          
          # Use GitHub Release CDN (fast mirror)
          SDK_URL="https://github.com/nagual2/openwrt-captive-monitor/releases/download/sdk-${SDK_VERSION}/${SDK_FILE}"
          
          # Fallback to official mirror if CDN fails
          FALLBACK_URL="https://downloads.openwrt.org/releases/${SDK_VERSION}/targets/x86/64/${SDK_FILE}"
          
          echo "ðŸ“¥ Downloading SDK from GitHub CDN (fast)..."
          # Enhanced retry logic for CDN download
          for attempt in {1..3}; do
            echo "Attempt $attempt/3: Downloading from CDN..."
            if wget --timeout=120 --tries=1 --retry-connrefused --waitretry=2 \
                   --random-wait -q "$SDK_URL" -O openwrt-sdk.tar.xz; then
              echo "âœ“ CDN download successful"
              break
            else
              if [ "$attempt" -lt 3 ]; then
                wait_time=$((2 ** (attempt - 1)))
                echo "âœ— CDN download failed, retrying in ${wait_time}s..."
                sleep "$wait_time"
              else
                echo "âš ï¸  CDN failed after 3 attempts, falling back to official mirror..."
                wget --timeout=300 --tries=3 -q "$FALLBACK_URL" -O openwrt-sdk.tar.xz
              fi
            fi
          done
          
          # Verify file was downloaded and has reasonable size
          if [ ! -f openwrt-sdk.tar.xz ]; then
            echo "âŒ SDK download failed - file not found"
            exit 1
          fi
          
          file_size=$(stat -c%s "openwrt-sdk.tar.xz")
          if [ "$file_size" -lt 100000000 ]; then
            echo "âŒ SDK file too small (${file_size} bytes), download incomplete"
            exit 1
          fi
          echo "âœ“ SDK size verified: ${file_size} bytes"
          
          # Verify checksum
          EXPECTED_SHA="${{ env.SDK_CHECKSUM }}"
          ACTUAL_SHA=$(sha256sum openwrt-sdk.tar.xz | awk '{print $1}')
          
          if [ "$EXPECTED_SHA" != "$ACTUAL_SHA" ]; then
            echo "âŒ Checksum mismatch!"
            echo "Expected: $EXPECTED_SHA"
            echo "Got: $ACTUAL_SHA"
            exit 1
          fi
          
          echo "âœ“ SDK verified"
          tar -xf openwrt-sdk.tar.xz
          rm openwrt-sdk.tar.xz
          echo "SDK extracted to: $SDK_DIR"

      - name: Install build dependencies
        run: |
          set -euxo pipefail
          
          # Configure apt for network resilience
          echo 'Acquire::http::Timeout "30";' | sudo tee -a /etc/apt/apt.conf.d/99timeout
          echo 'Acquire::https::Timeout "30";' | sudo tee -a /etc/apt/apt.conf.d/99timeout
          echo 'Acquire::Retries "3";' | sudo tee -a /etc/apt/apt.conf.d/99retry
          
          # Update with retry logic
          for attempt in {1..3}; do
            echo "Attempt $attempt/3: Updating package lists..."
            if sudo apt-get update -o Acquire::http::Timeout=30 -o Acquire::https::Timeout=30 -o Acquire::Retries=3; then
              echo "âœ“ Package update successful"
              break
            else
              if [ "$attempt" -lt 3 ]; then
                echo "âœ— Package update failed, retrying in 10s..."
                sleep 10
              else
                echo "âŒ Package update failed after 3 attempts"
                exit 1
              fi
            fi
          done
          
          # Install dependencies with retry
          for attempt in {1..3}; do
            echo "Attempt $attempt/3: Installing dependencies..."
            if sudo apt-get install -y --no-install-recommends \
              build-essential \
              libncurses5-dev \
              zlib1g-dev \
              gawk \
              git \
              gettext \
              libssl-dev \
              python3 \
              unzip \
              wget \
              libncursesw5-dev \
              libgmp-dev \
              libmpfr-dev \
              libmpc-dev \
              flex \
              bison; then
              echo "âœ“ Dependencies installed successfully"
              break
            else
              if [ "$attempt" -lt 3 ]; then
                echo "âœ— Dependency installation failed, retrying in 10s..."
                sleep 10
              else
                echo "âŒ Dependency installation failed after 3 attempts"
                exit 1
              fi
            fi
          done

      - name: Sync package to SDK with clean copy strategy
        run: |
          set -euo pipefail
          SDK_DIR="${{ env.SDK_DIR }}"
          PACKAGE_DIR="$SDK_DIR/package/${{ env.PACKAGE_NAME }}"
          
          # Clean any existing package directory completely
          rm -rf "$PACKAGE_DIR"
          
          # Create fresh package directory
          mkdir -p "$PACKAGE_DIR"
          
          # Copy package contents including VERSION file and license
          cp -r package/${{ env.PACKAGE_NAME }}/* "$PACKAGE_DIR/"
          
          # Copy VERSION file to package directory
          cp VERSION "$PACKAGE_DIR/"
          
          # Copy LICENSE file to files subdirectory
          mkdir -p "$PACKAGE_DIR/files/"
          cp LICENSE "$PACKAGE_DIR/files/"
          
          echo "Package synced to SDK at: $PACKAGE_DIR"
          echo "Package contents:"
          ls -la "$PACKAGE_DIR/"
          echo "Files subdirectory contents:"
          ls -la "$PACKAGE_DIR/files/" 2>/dev/null || true

      - name: Update and install feeds
        run: |
          set -euo pipefail
          SDK_DIR="${{ env.SDK_DIR }}"
          cd "$SDK_DIR"
          
          # Configure Git for large transfers
          git config --global http.postBuffer 524288000
          git config --global core.compression 0
          
          # Function to update feeds with exponential backoff and jitter
          update_feeds_with_retry() {
            local max_attempts=10
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: Updating feeds..."
              
              # Clear cache before each attempt to prevent stale data
              echo "Clearing feed cache before attempt $attempt..."
              rm -rf feeds/
              rm -f feeds.conf.old
              
              if ./scripts/feeds update -a; then
                echo "âœ“ Feeds updated successfully"
                return 0
              fi
              
              if [ $attempt -lt $max_attempts ]; then
                # Exponential backoff with jitter (1s, 2s, 4s, 8s, 16s, 32s, 64s, 128s, 256s)
                local base_wait=$((2 ** (attempt - 1)))
                # Add jitter: 20% random variation
                local jitter=$((base_wait / 5))
                local wait_time=$((base_wait + RANDOM % jitter))
                echo "âœ— Feed update failed, waiting ${wait_time}s before retry (base: ${base_wait}s, jitter: +$((RANDOM % jitter))s)..."
                sleep "$wait_time"
              fi
              attempt=$((attempt + 1))
            done
            
            echo "âœ— Feed update failed after $max_attempts attempts"
            return 1
          }
          
          # Function to install feeds with exponential backoff and jitter
          install_feeds_with_retry() {
            local max_attempts=10
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: Installing feeds..."
              if ./scripts/feeds install -a; then
                echo "âœ“ Feeds installed successfully"
                return 0
              fi
              
              if [ $attempt -lt $max_attempts ]; then
                # Exponential backoff with jitter (1s, 2s, 4s, 8s, 16s, 32s, 64s, 128s, 256s)
                local base_wait=$((2 ** (attempt - 1)))
                # Add jitter: 20% random variation
                local jitter=$((base_wait / 5))
                local wait_time=$((base_wait + RANDOM % jitter))
                echo "âœ— Feed install failed, waiting ${wait_time}s before retry (base: ${base_wait}s, jitter: +$((RANDOM % jitter))s)..."
                sleep "$wait_time"
              fi
              attempt=$((attempt + 1))
            done
            
            echo "âœ— Feed install failed after $max_attempts attempts"
            return 1
          }
          
          # Update feeds with retry logic (includes cache clearing)
          update_feeds_with_retry || exit 1
          
          # Install feeds with retry logic
          install_feeds_with_retry || exit 1
          
          echo "Feeds updated and installed successfully"

      - name: Configure SDK
        run: |
          set -euo pipefail
          SDK_DIR="${{ env.SDK_DIR }}"
          cd "$SDK_DIR"

          echo "Configuring SDK with defconfig..."
          make defconfig

          echo "SDK configuration completed"

      - name: Clean SDK environment
        run: |
          set -euo pipefail
          SDK_DIR="${{ env.SDK_DIR }}"
          cd "$SDK_DIR"

          echo "Cleaning SDK environment..."

          # Clean previous build artifacts
          make distclean || true

          # Use defconfig in CI for consistent configuration
          make defconfig < /dev/null || {
            echo "defconfig failed, trying fallback configuration..."
            make defconfig
          }

          echo "SDK environment cleaned successfully"

      - name: Build toolchain
        run: |
          set -euo pipefail
          SDK_DIR="${{ env.SDK_DIR }}"
          cd "$SDK_DIR"

          echo "Building and installing OpenWrt toolchain..."
          echo "This ensures staging_dir is properly initialized with all toolchain files including ld-musl"

          # Build toolchain with verbose output to diagnose issues
          if ! make toolchain/install V=s 2>&1 | tee toolchain_build.log; then
            echo "=== TOOLCHAIN BUILD FAILED ==="
            echo "Last 50 lines of toolchain build log:"
            tail -50 toolchain_build.log
            exit 1
          fi

          echo "=== Toolchain build completed successfully ==="

          # Verify staging_dir structure
          if [ -d staging_dir ]; then
            echo "Toolchain staging_dir contents:"
            find staging_dir -name "ld-musl*" -o -name "libc.so*" | head -20
          else
            echo "Warning: staging_dir not found after toolchain build"
          fi

      - name: Compile package
        run: |
          set -euo pipefail
          SDK_DIR="${{ env.SDK_DIR }}"
          cd "$SDK_DIR"
          
          echo "Compiling ${{ env.PACKAGE_NAME }} package with verbose output..."
          
          # Build with verbose output and logging
          if ! make package/${{ env.PACKAGE_NAME }}/compile V=s 2>&1 | tee build.log; then
            echo "=== BUILD FAILED ==="
            echo "Build command failed"
            echo ""
            echo "=== Last 100 lines of build log ==="
            tail -100 build.log
            echo ""
            echo "=== Available build logs ==="
            find . -name "*.log" -exec echo "=== {} ===" \; -exec tail -50 {} \;
            echo ""
            echo "=== Makefile errors ==="
            find . -name ".*.cmd" -exec echo "=== {} ===" \; -exec cat {} \; 2>/dev/null || true
            exit 1
          fi
          
          echo "Package compilation completed successfully"
          echo "Build log size: $(wc -l < build.log) lines"

      - name: Locate built package and prepare artifacts
        run: |
          set -euo pipefail
          SDK_DIR="${{ env.SDK_DIR }}"
          
          # Find the built packages directory
          PKG_DIR=$(find "$SDK_DIR/bin" -type d -name "packages" | head -n1)
          if [ -z "$PKG_DIR" ]; then
            echo "Error: Could not find packages directory"
            find "$SDK_DIR/bin" -type d | head -10
            exit 1
          fi
          
          echo "Found packages directory: $PKG_DIR"
          
          # Find the IPK file
          IPK_FILE=$(find "$PKG_DIR" -name "${{ env.PACKAGE_NAME }}_*.ipk" | head -n1)
          if [ -z "$IPK_FILE" ]; then
            echo "Error: Could not find built .ipk file"
            find "$PKG_DIR" -name "*.ipk" | head -10
            exit 1
          fi
          
          echo "Found IPK: $IPK_FILE"
          echo "IPK_FILE=$IPK_FILE" >> "$GITHUB_ENV"
          echo "IPK_NAME=$(basename "$IPK_FILE")" >> "$GITHUB_ENV"
          
          # Create artifacts directory
          mkdir -p artifacts
          cp "$IPK_FILE" artifacts/
          
          # Copy any Packages* index files if they exist
          find "$PKG_DIR" -name "Packages*" -exec cp {} artifacts/ \;
          
          # List artifacts for verification
          echo "Artifacts prepared for upload:"
          ls -la artifacts/

      - name: Validate built package
        run: |
          set -euo pipefail
          if [ -n "${{ env.IPK_FILE }}" ]; then
            echo "Validating built package..."
            ./scripts/validate_ipk.sh "${{ env.IPK_FILE }}"
            echo "Package validation successful"
          else
            echo "Error: IPK_FILE environment variable not set"
            exit 1
          fi

      - name: Upload package artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PACKAGE_NAME }}-package
          path: artifacts/
          retention-days: 30
          if-no-files-found: error

      - name: Display package information
        run: |
          set -euo pipefail
          if [ -n "${{ env.IPK_FILE }}" ]; then
            echo "=== Package Information ==="
            echo "File: ${{ env.IPK_NAME }}"
            echo "Size: $(stat -c%s "${{ env.IPK_FILE }}") bytes"
            
            # Extract and display control information
            TEMP_DIR=$(mktemp -d)
            cd "$TEMP_DIR"
            ar x "${{ env.IPK_FILE }}"
            tar -xzf control.tar.gz
            
            echo ""
            echo "=== Package Control Information ==="
            cat control
            
            rm -rf "$TEMP_DIR"
          fi