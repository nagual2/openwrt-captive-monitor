name: Build OpenWrt Package

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read

defaults:
  run:
    shell: bash

env:
  OPENWRT_VERSION: "23.05.3"
  SDK_CHECKSUM: "f90d60c7a00a50a1c80807fb32fd4c12bed1fb65871328f3c2171caf9b711254"

jobs:
  build:
    name: Build OpenWrt package
    runs-on: ubuntu-latest

    steps:
      - name: Check out repository
        uses: actions/checkout@v5

      - name: Download and extract OpenWrt SDK from GitHub CDN
        run: |
          set -euo pipefail
          SDK_VERSION="${{ env.OPENWRT_VERSION }}"
          SDK_FILE="openwrt-sdk-${SDK_VERSION}-x86-64_gcc-12.3.0_musl.Linux-x86_64.tar.xz"
          SDK_DIR="openwrt-sdk-${SDK_VERSION}-x86-64_gcc-12.3.0_musl.Linux-x86_64"
          PACKAGE_NAME="openwrt-captive-monitor"
          
          # Export for subsequent steps
          echo "SDK_DIR=$SDK_DIR" >> "$GITHUB_ENV"
          echo "PACKAGE_NAME=$PACKAGE_NAME" >> "$GITHUB_ENV"
          
          # Use GitHub Release CDN (fast mirror)
          SDK_URL="https://github.com/nagual2/openwrt-captive-monitor/releases/download/sdk-${SDK_VERSION}/${SDK_FILE}"
          
          # Fallback to official mirror if CDN fails
          FALLBACK_URL="https://downloads.openwrt.org/releases/${SDK_VERSION}/targets/x86/64/${SDK_FILE}"
          
          echo "ðŸ“¥ Downloading SDK from GitHub CDN (fast)..."
          if ! wget -q "$SDK_URL" -O openwrt-sdk.tar.xz; then
            echo "âš ï¸  CDN failed, falling back to official mirror..."
            wget -q "$FALLBACK_URL" -O openwrt-sdk.tar.xz
          fi
          
          # Verify checksum
          EXPECTED_SHA="${{ env.SDK_CHECKSUM }}"
          ACTUAL_SHA=$(sha256sum openwrt-sdk.tar.xz | awk '{print $1}')
          
          if [ "$EXPECTED_SHA" != "$ACTUAL_SHA" ]; then
            echo "âŒ Checksum mismatch!"
            echo "Expected: $EXPECTED_SHA"
            echo "Got: $ACTUAL_SHA"
            exit 1
          fi
          
          echo "âœ“ SDK verified"
          tar -xf openwrt-sdk.tar.xz
          rm openwrt-sdk.tar.xz
          echo "SDK extracted to: $SDK_DIR"

      - name: Install build dependencies
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            build-essential \
            libncurses5-dev \
            zlib1g-dev \
            gawk \
            git \
            gettext \
            libssl-dev \
            python3 \
            unzip \
            wget \
            libncursesw5-dev \
            libgmp-dev \
            libmpfr-dev \
            libmpc-dev \
            flex \
            bison

      - name: Sync package to SDK with clean copy strategy
        run: |
          set -euo pipefail
          SDK_DIR="${{ env.SDK_DIR }}"
          PACKAGE_DIR="$SDK_DIR/package/${{ env.PACKAGE_NAME }}"
          
          # Clean any existing package directory completely
          rm -rf "$PACKAGE_DIR"
          
          # Create fresh package directory
          mkdir -p "$PACKAGE_DIR"
          
          # Copy package contents including VERSION file and license
          cp -r package/${{ env.PACKAGE_NAME }}/* "$PACKAGE_DIR/"
          
          # Copy VERSION file to package directory
          cp VERSION "$PACKAGE_DIR/"
          
          # Copy LICENSE file to files subdirectory
          mkdir -p "$PACKAGE_DIR/files/"
          cp LICENSE "$PACKAGE_DIR/files/"
          
          echo "Package synced to SDK at: $PACKAGE_DIR"
          echo "Package contents:"
          ls -la "$PACKAGE_DIR/"
          echo "Files subdirectory contents:"
          ls -la "$PACKAGE_DIR/files/" 2>/dev/null || true

      - name: Update and install feeds
        run: |
          set -euo pipefail
          SDK_DIR="${{ env.SDK_DIR }}"
          cd "$SDK_DIR"
          
          # Configure Git for large transfers
          git config --global http.postBuffer 524288000
          git config --global core.compression 0
          
          # Function to update feeds with exponential backoff
          update_feeds_with_retry() {
            local max_attempts=5
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: Updating feeds..."
              if ./scripts/feeds update -a; then
                echo "âœ“ Feeds updated successfully"
                return 0
              fi
              
              if [ $attempt -lt $max_attempts ]; then
                local wait_time=$((2 ** (attempt - 1)))
                echo "âœ— Feed update failed, waiting ${wait_time}s before retry..."
                sleep "$wait_time"
              fi
              attempt=$((attempt + 1))
            done
            
            echo "âœ— Feed update failed after $max_attempts attempts"
            return 1
          }
          
          # Function to install feeds with exponential backoff
          install_feeds_with_retry() {
            local max_attempts=5
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: Installing feeds..."
              if ./scripts/feeds install -a; then
                echo "âœ“ Feeds installed successfully"
                return 0
              fi
              
              if [ $attempt -lt $max_attempts ]; then
                local wait_time=$((2 ** (attempt - 1)))
                echo "âœ— Feed install failed, waiting ${wait_time}s before retry..."
                sleep "$wait_time"
              fi
              attempt=$((attempt + 1))
            done
            
            echo "âœ— Feed install failed after $max_attempts attempts"
            return 1
          }
          
          # Clear feed cache to prevent stale data issues
          echo "Clearing feed cache..."
          rm -rf feeds/
          rm -f feeds.conf.old
          
          # Update feeds with retry logic
          update_feeds_with_retry || exit 1
          
          # Install feeds with retry logic
          install_feeds_with_retry || exit 1
          
          echo "Feeds updated and installed successfully"

      - name: Configure SDK
        run: |
          set -euo pipefail
          SDK_DIR="${{ env.SDK_DIR }}"
          cd "$SDK_DIR"
          
          echo "Configuring SDK with defconfig..."
          make defconfig
          
          echo "SDK configuration completed"

      - name: Clean SDK environment
        run: |
          set -euo pipefail
          SDK_DIR="${{ env.SDK_DIR }}"
          cd "$SDK_DIR"
          
          echo "Cleaning SDK environment..."
          
          # Clean previous build artifacts
          make distclean || true
          
          # Use defconfig in CI for consistent configuration
          make defconfig < /dev/null || {
            echo "defconfig failed, trying fallback configuration..."
            make defconfig
          }
          
          echo "SDK environment cleaned successfully"

      - name: Compile package
        run: |
          set -euo pipefail
          SDK_DIR="${{ env.SDK_DIR }}"
          cd "$SDK_DIR"
          
          echo "Compiling ${{ env.PACKAGE_NAME }} package with verbose output..."
          
          # Build with verbose output and logging
          if ! make package/${{ env.PACKAGE_NAME }}/compile V=s 2>&1 | tee build.log; then
            echo "=== BUILD FAILED ==="
            echo "Build command failed"
            echo ""
            echo "=== Last 100 lines of build log ==="
            tail -100 build.log
            echo ""
            echo "=== Available build logs ==="
            find . -name "*.log" -exec echo "=== {} ===" \; -exec tail -50 {} \;
            echo ""
            echo "=== Makefile errors ==="
            find . -name ".*.cmd" -exec echo "=== {} ===" \; -exec cat {} \; 2>/dev/null || true
            exit 1
          fi
          
          echo "Package compilation completed successfully"
          echo "Build log size: $(wc -l < build.log) lines"

      - name: Locate built package and prepare artifacts
        run: |
          set -euo pipefail
          SDK_DIR="${{ env.SDK_DIR }}"
          
          # Find the built packages directory
          PKG_DIR=$(find "$SDK_DIR/bin" -type d -name "packages" | head -n1)
          if [ -z "$PKG_DIR" ]; then
            echo "Error: Could not find packages directory"
            find "$SDK_DIR/bin" -type d | head -10
            exit 1
          fi
          
          echo "Found packages directory: $PKG_DIR"
          
          # Find the IPK file
          IPK_FILE=$(find "$PKG_DIR" -name "${{ env.PACKAGE_NAME }}_*.ipk" | head -n1)
          if [ -z "$IPK_FILE" ]; then
            echo "Error: Could not find built .ipk file"
            find "$PKG_DIR" -name "*.ipk" | head -10
            exit 1
          fi
          
          echo "Found IPK: $IPK_FILE"
          echo "IPK_FILE=$IPK_FILE" >> "$GITHUB_ENV"
          echo "IPK_NAME=$(basename "$IPK_FILE")" >> "$GITHUB_ENV"
          
          # Create artifacts directory
          mkdir -p artifacts
          cp "$IPK_FILE" artifacts/
          
          # Copy any Packages* index files if they exist
          find "$PKG_DIR" -name "Packages*" -exec cp {} artifacts/ \;
          
          # List artifacts for verification
          echo "Artifacts prepared for upload:"
          ls -la artifacts/

      - name: Validate built package
        run: |
          set -euo pipefail
          if [ -n "${{ env.IPK_FILE }}" ]; then
            echo "Validating built package..."
            ./scripts/validate_ipk.sh "${{ env.IPK_FILE }}"
            echo "Package validation successful"
          else
            echo "Error: IPK_FILE environment variable not set"
            exit 1
          fi

      - name: Upload package artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PACKAGE_NAME }}-package
          path: artifacts/
          retention-days: 30
          if-no-files-found: error

      - name: Display package information
        run: |
          set -euo pipefail
          if [ -n "${{ env.IPK_FILE }}" ]; then
            echo "=== Package Information ==="
            echo "File: ${{ env.IPK_NAME }}"
            echo "Size: $(stat -c%s "${{ env.IPK_FILE }}") bytes"
            
            # Extract and display control information
            TEMP_DIR=$(mktemp -d)
            cd "$TEMP_DIR"
            ar x "${{ env.IPK_FILE }}"
            tar -xzf control.tar.gz
            
            echo ""
            echo "=== Package Control Information ==="
            cat control
            
            rm -rf "$TEMP_DIR"
          fi